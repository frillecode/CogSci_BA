---
title: "testing"
author: "Frida HÃ¦strup"
date: "23/8/2020"
output: html_document
---

```{r}
library(pacman)
pacman::p_load(bibtex, bibliometrix, bib2df, igraph, ggraph, tidyverse, stringr, dplyr)
```

### DATA PREPARATION ###
```{r}

#### First, we want to load data from the IDS metaanalysis into a dataframe ####

# Loading data 
IDS <- read.csv("Data/Meta-analytic datasets/Infant directed speech preference.csv")

#### Then, we create a new dataframe that contains all articles with a row for each of their citations ####

# Loading data with cited references of all the articles in the metaanalysis from Web of Science
data <- convert2df("Data/WOS_citations/savedrecs.bib",  dbsource = 'wos',format = "bibtex")

# Extracting relevant columns
df <- cbind(data$AU,  data$TI, data$CR, data$NR, data$PY)
df <- as.data.frame(df)
colnames(df) <- c("author", "title", "CR", "n_ref", "year")

# Looping through each article - splitting CR into individual citations

CIT <- as.data.frame(matrix(0,nrow = 0, ncol = 6)) #empty dataframe for loop

for (i in df$title){
  this_data_set <- df[df$title == i,]
  
  k <- merge(str_split(this_data_set$CR, ";"), this_data_set)
  colnames(k) <- c("citations","author", "title", "CR", "n_ref", "year") 
  
  
  if(nrow(CIT) == 0){
    CIT <- k
  }else{
    CIT <- rbind(CIT, k)
  }
}

##### Now, we clean the data so that we can compare IDS and citation dataframes #####

# Add studyID for each citation
CIT$citID <- paste(str_extract(CIT$citations, "[:alpha:]+"), str_extract(CIT$citations, "\\d+"), sep = "") 

# Add studyID for each article
CIT$studyID <- paste(str_extract(CIT$author, "[:alpha:]+"), CIT$year, sep = "") 

# Making study_ID in IDS dataframe uppercase (same as cit)
IDS$study_ID <- toupper(IDS$study_ID)

# Filter so that only citations of other studies in the analysis are kept
CIT_fixed <- CIT %>% 
  filter(citID %in% studyID)

# Sorting the two dataframes by ascending order based on the year of publication
CIT_fixed <- CIT_fixed[order(CIT_fixed$year),]
IDS_fixed <- IDS[order(IDS$year),]

```

### CHAINS OF TRANSMISSION ###
```{r}

library(igraph, ggraph)

nodes <- data.frame(id = unique(CIT$studyID))
edges <- data.frame(
  from = CIT_fixed$citID,
  to = CIT_fixed$studyID,
  year = CIT_fixed$year
)

nodes$id <- as.character(nodes$id)
edges$from <- as.character(edges$from)
edges$to <- as.character(edges$to)


for (node in nodes$id) {
  edge <- subset(edges, to == node) #filter one node
  if(nrow(edge)>0){
    for (i in 1:nrow(edge)){
    cite <- edges %>% filter(to == edge$from[i]) #filter all the studies the node cites
    if(nrow(cite)>0){ #if a study is both cited by the cited study and the node
      for (c in 1:nrow(cite)){
        if(cite$from[c] %in% edge$from){
          edges <- edges[!(edges$from == cite$from[c] & edges$to == edge$to[i]),]
        }
      }
    }
  }
  }
}

#using unfiltered edgelist to calculate degree distribution of cit_network
edges2 <- as.matrix(edges[,1:2])

graph <- graph_from_edgelist(edges2)

dd <- degree_distribution(graph)


#creating BA-network
graph_ba <- barabasi.game(60, out.dist = dd) 
        #linear pa - great for citation network
        #used dd from above as the distribution of the number of edges to add in each time step
degree_distribution(graph_ba)
degree(graph_ba)
plot(graph_ba) 


# Polotting
pacman::p_load(devtools)
install_github("gastonstat/arcdiagram")
library(arcdiagram)

edges_ordered <- edges[order(as.numeric(edges$to)),]
edges_for_plotting <- as.matrix(edges_ordered)

arcplot(edges_for_plotting, cex.labels = 0.6, cex.nodes = 0.7, lwd.arcs = 0.7)

```



### NEW CHAINS OF TRANSMISSION ###

```{r}
### CREATING CHAIN ###

# Empty dataframe
chain <- as.data.frame(matrix(0, nrow = 1, ncol = 3)) 
colnames(chain) <- c("studyID", "n_cits", "citations")
study <- 1

# Create citations
while(study < 61){

n_cits <- 0
citations <- c()    

if (study == 1){ #add first study to chain (no citations)
  chain$studyID <- study
  chain$n_cits <- n_cits
  chain$citations <- NA
  
  #update studyID
  study <- study + 1
  
}else{ #for all following studies

  #create citations by looping through each of the previous studies
      
    #subset df with all expect this study
    #previous_studies <- subset(chain, !(studyID == study))
  
    #loop through each study
    for (citedID in unique(chain$studyID)){
      
      #probability of being cited depends on 
      p <- length(which(chain$citations == citedID))/(study-1)
      if(p == 0){p <- 0.5}
      is_cited <- rbinom(1, 1, p)
      
      #number of citations
      n_cits <- n_cits + is_cited
      
      if (is_cited == 1){
      #list of citations
      citations <- c(citations, citedID)
       }
      }
      
      #create data frame where citations are split into individual rows
      if(length(citations)>0){
      this_chain <- as.data.frame(matrix(0, nrow = length(citations), ncol = 3)) 
      colnames(this_chain) <- colnames(chain)
      
      this_chain$studyID <- study   
      this_chain$n_cits <- n_cits
      this_chain$citations <- str_split(citations, ",")
      
      #add all of this to a data frame
      chain <- rbind(chain, this_chain)
      
      #update studyID
      study <- study+1
      }
  }      
}





for (i in 1:length(nodes$id)){
  sub <- chain[chain$citations == nodes$id[i],]
  nodes$n_cited[i] <- nrow(sub)
}

nodes$n_cited_p <- nodes$n_cited/nrow(nodes)

### CREATING EDGELIST ###

nodes <- data.frame(id = unique(c(chain$studyID)))

chain <- chain[-1,]

edges <- as.data.frame(matrix(0, nrow=0, ncol=2))
colnames(edges) <- c("citations", "studyID")
edges<- rbind(chain, edges)
edges <- edges[,-2]
colnames(edges) <- c("to","from")

nodes$id <- as.character(nodes$id)
edges$from <- as.character(edges$from)
edges$to <- as.character(edges$to)

for (node in nodes$id) {
  edge <- subset(edges, to == node) #filter one node
  if(nrow(edge)>0){
    for (i in 1:nrow(edge)){
    cite <- edges %>% filter(to == edge$from[i]) #filter all the studies the node cites
    if(nrow(cite)>0){ #if a study is both cited by the cited study and the node
      for (c in 1:nrow(cite)){
        if(cite$from[c] %in% edge$from){ 
          edges <- edges[!(edges$from == cite$from[c] & edges$to == edge$to[i]),]
        }
      }
    }
  }
  }
}

# Polotting
pacman::p_load(devtools)
install_github("gastonstat/arcdiagram")
library(arcdiagram)

edges_ordered <- edges[order(as.numeric(edges$to)),]
edges_for_plotting <- as.matrix(edges_ordered)

arcplot(edges_for_plotting, cex.labels = 0.6, cex.nodes = 0.7, lwd.arcs = 0.7)
```

